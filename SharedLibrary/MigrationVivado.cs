using System;
using System.Collections.Generic;
using System.Linq;
using System.Xml;
using System.IO;
using System.IO.Compression;
using System.Text.RegularExpressions;

namespace Migrations {
    public class MigrationVivado : MigrationCommon {

        string projectName;
        string projectFileDir;
        XmlDocument projectDoc;
        List<VDag> sources;
        VDag projectDag;

        public MigrationVivado() : base() {
            migrationType = "vivado";
            sources = new List<VDag>();

            projectDag = new VDag();
            projectDag.type = SourceType.XPR;
        }

        protected override int MigrateProjectSpecific() {
            int returnVal;
            string sourcesDump = "";
#if DEBUG
            bool doDump = true;
#else
            bool doDump = false;
#endif

            try {
                Log("Step 1/10: ParseXPR...\n");
                ParseXPR();
                if (doDump) sourcesDump += dumpSources("ParseXPR");
            }
            catch (Exception ex) {
                Log("ERROR - ParseXPR failed: " + ex.Message);
                return ERRORCODE_INVALID_PROJECT_FILE;
            }

            try {
                Log("Step 2/10: RemoveRefXcis...\n");
                RemoveRefXcis();
                if (doDump) sourcesDump += dumpSources("RemoveRefXcis");
            }
            catch (Exception ex) {
                Log("Warning - RemoveRefXcis failed: " + ex.Message);
            }

            try {
                Log("Step 3/10: CreateSurrogates...\n");
                CreateSurrogates();
                if (doDump) sourcesDump += dumpSources("CreateSurrogates");
            }
            catch (Exception ex) {
                Log("Warning - CreateSurrogates failed: " + ex.Message);
            }

            try {
                Log("Step 4/10: FindIpsFromBds...\n");
                FindIpsFromBds();
                if (doDump) sourcesDump += dumpSources("FindIpsFromBds");
            }
            catch (Exception ex) {
                Log("Warning - FindIpsFromBds failed: " + ex.Message);
            }

            try {
                Log("Step 4.5/10: LinkXitFilesToParentIp...\n");
                LinkXitFilesToParentIp();
                if (doDump) sourcesDump += dumpSources("LinkXitFilesToParentIp");
            }
            catch (Exception ex) {
                Log("Warning - LinkXitFilesToParentIp failed: " + ex.Message);
            }

            try {
                Log("Step 5/10: FindCoesForIps...\n");
                FindCoesForIps();
                if (doDump) sourcesDump += dumpSources("FindCoesForIps");
            }
            catch (Exception ex) {
                Log("Warning - FindCoesForIps failed: " + ex.Message);
            }

            try {
                Log("Step 6/10: ResolveCopyOrder...\n");
                ResolveCopyOrder();
                if (doDump) sourcesDump += dumpSources("ResolveCopyOrder");
            }
            catch (Exception ex) {
                Log("Warning - ResolveCopyOrder failed: " + ex.Message);
            }

            Log("Step 7/10: ResolveMatchingNames...\n");
            if ((returnVal = ResolveMatchingNames()) != 0) return returnVal;
            if (doDump) sourcesDump += dumpSources("ResolveMatchingNames");

            try {
                Log("Step 8/10: DoMigration (" + sources.Count + " files)...\n");
                DoMigration();
                if (doDump) sourcesDump += dumpSources("DoMigration");
            }
            catch (Exception ex) {
                Log("ERROR - DoMigration failed: " + ex.Message);
            }

            try {
                Log("Step 9/10: WalkDags...\n");
                WalkDags();
                if (doDump) sourcesDump += dumpSources("WalkDags");
            }
            catch (Exception ex) {
                Log("Warning - WalkDags failed: " + ex.Message);
            }

            Log("Step 10/10: Finalizing...\n");
            SaveProjectDoc();

            CopyBitFile();

            CopyVitisProject();

            return 0;
        }

        private string dumpSources(string doneAfter) {
            string dump = "<table><tr><th>" + doneAfter + "</th><th>UUID</th><th>Target Location</th><th>Node</th></tr>";
            int i = 0;

            foreach (VDag dag in sources) {
                i++;
                dump += "<tr><td>" + i + "</td><td>" + dag.uuid + "</td><td>" + dag.targetLocation + "</td><td>" + dag.fileNode + "</td></tr>";
            }

            dump += "</table><br>";
            return dump;
        }

        protected override void CreateGitIgnoreSpecific() {
            File.WriteAllText(FolderStructure.sourcesDir + "\\.gitignore", 
                "# Vivado generated files\n" +
                "*.dcp\n" +
                "*.log\n" +
                "*.jou\n" +
                "\n" +
                "# Work directory (regenerated by Vivado)\n" +
                "work/\n" +
                "\n" +
                "# Vitis build outputs\n" +
                "vitis/**/Debug/\n" +
                "vitis/**/Release/\n" +
                "vitis/**/.metadata/\n" +
                "vitis/**/_ide/\n" +
                "*.o\n" +
                "*.d\n" +
                "*.map\n" +
                "");
        }

        private int ParseXPR() {
            projectName = GetFileNameWoExt(projectFileFA);
            projectFileDir = Directory.GetParent(projectFileFA).FullName;

            Log("Reading xpr file: " + projectFileFA);

            projectDoc = new XmlDocument();
            projectDoc.PreserveWhitespace = true;
            projectDoc.Load(projectFileFA);

            XmlNode projectNode = projectDoc.SelectSingleNode("/Project");
            projectNode.Attributes["Path"].Value = FolderStructure.workDir.Replace('\\', '/') + "/" + projectName + ".xpr";
            XmlNode ipRepoNode = projectDoc.SelectSingleNode("/Project/Configuration/Option[@Name='IPRepoPath']");
            string ipRepoPath = null;

            if (ipRepoNode is object) {
                ipRepoPath = ipRepoNode.Attributes["Val"].Value;
                // IP Repo path'ini kaydet - sonra kopyalanacak
                CopyIpRepo(ipRepoPath);
            }

            XmlNode ipUserFilesNode = projectDoc.SelectSingleNode("/Project/Configuration/Option[@Name='IPUserFilesDir']");

            if (ipUserFilesNode is object) {
                Directory.CreateDirectory(ConvertPathXPRtoMSW(ipUserFilesNode.Attributes["Val"].Value, FolderStructure.workDir));
            }

            XmlNode ipStaticSourceDir = projectDoc.SelectSingleNode("/Project/Configuration/Option[@Name='IPStaticSourceDir']");

            if (ipStaticSourceDir is object) {
                Directory.CreateDirectory(ConvertPathXPRtoMSW(ipStaticSourceDir.Attributes["Val"].Value, FolderStructure.workDir));
            }

            XmlNode ipOutputRepo = projectDoc.SelectSingleNode("/Project/Configuration/Option[@Name='IPOutputRepo']");

            if (ipOutputRepo is object) {
                ipOutputRepo.ParentNode.RemoveChild(ipOutputRepo);
            }

            // Set filesets' paths to local
            foreach (XmlNode node in projectDoc.SelectNodes("//FileSet[@Type='DesignSrcs']" +
                                                     "| //FileSet[@Type='Constrs']" +
                                                     "| //FileSet[@Type='SimulationSrcs']" +
                                                     "| //FileSet[@Type='Utils']" +
                                                     "| //FileSet[@Type='BlockSrcs']")) {
                XmlNode fileSetName = node.Attributes["Name"];
                XmlNode relSrcDir = node.Attributes["RelSrcDir"];

                if (!Regex.IsMatch(relSrcDir.Value, "^\\$PSRCDIR", RegexOptions.IgnoreCase)) {
                    Log(fileSetName.Value + " is not local: " + relSrcDir.Value);
                    relSrcDir.Value = "$PSRCDIR/" + fileSetName.Value;
                }
            }

            // Read source references
            foreach (XmlNode fileNode in projectDoc.SelectNodes("//FileSet/File")) {
                XmlNode fileSetNode = fileNode.ParentNode;
                XmlNode filePath = fileNode.Attributes["Path"];
                string fileSetType = fileSetNode.Attributes["Type"].Value;

                // Create a DAG
                VDag dag = new VDag();
                dag.name = GetFileNameWExt(filePath.Value);
                dag.fileNode = fileNode;

                // Check if the file exists
                dag.sourceFA = ConvertPathXPRtoMSW(filePath.Value);

                if (!File.Exists(dag.sourceFA)) {
                    dag.isCopied = false;
                    dag.isLost = true;
                }

                // Figure out which source type it is
                // ÖNCE özel dosya türlerini kontrol et (ELF, XSA vs.)
                if (Regex.IsMatch(filePath.Value, @"\.elf$", RegexOptions.IgnoreCase)) {
                    // It is an embedded elf file, copy it to /elf
                    dag.type = SourceType.ELF;
                }

                else if (Regex.IsMatch(filePath.Value, @"\.xsa$", RegexOptions.IgnoreCase)) {
                    // It is a hardware export file for Vitis, copy it to /hw_export
                    dag.type = SourceType.HW_EXPORT;
                }

                else if (fileSetType.Equals("SimulationSrcs", StringComparison.OrdinalIgnoreCase)) {
                    // It is related to simulation, copy it to /sim
                    dag.type = SourceType.SIM;
                }

                else if (fileSetType.Equals("Utils", StringComparison.OrdinalIgnoreCase)) {
                    // It is uncommon, copy it to /other
                    dag.type = SourceType.OTHER;
                }

                else if (fileSetType.Equals("Constrs", StringComparison.OrdinalIgnoreCase)) {
                    // It is an xdc file, copy it to /const
                    dag.type = SourceType.CONST;
                }

                else if ((fileSetType.Equals("BlockSrcs", StringComparison.OrdinalIgnoreCase)
                    || fileSetType.Equals("DesignSrcs", StringComparison.OrdinalIgnoreCase))
                    && Regex.IsMatch(filePath.Value, @"\.xcix$", RegexOptions.IgnoreCase)) {
                    // It is a managed ip archive, unzip it to /ip
                    dag.type = SourceType.IP_XCIX;
                }

                else if ((fileSetType.Equals("BlockSrcs", StringComparison.OrdinalIgnoreCase)
                    || fileSetType.Equals("DesignSrcs", StringComparison.OrdinalIgnoreCase))
                    && Regex.IsMatch(filePath.Value, @"\.xci$", RegexOptions.IgnoreCase)) {
                    // It is a regular ip descriptor, copy its folder to /ip
                    dag.type = SourceType.IP;
                }

                else if ((fileSetType.Equals("BlockSrcs", StringComparison.OrdinalIgnoreCase)
                    || fileSetType.Equals("DesignSrcs", StringComparison.OrdinalIgnoreCase))
                    && Regex.IsMatch(filePath.Value, @"\.xit$", RegexOptions.IgnoreCase)) {
                    // It is a subcore ip template file (.xit), will be carried with parent IP
                    // XIT dosyası subcore için - ana IP klasörü altında olmalı
                    dag.type = SourceType.IP;
                    // NOT: Eğer bu XIT bir IP klasörü altındaysa, sonradan FindIpsFromBds veya 
                    // başka bir fonksiyonda isCarried olarak işaretlenecek
                }

                else if ((fileSetType.Equals("BlockSrcs", StringComparison.OrdinalIgnoreCase)
                    || fileSetType.Equals("DesignSrcs", StringComparison.OrdinalIgnoreCase))
                    && Regex.IsMatch(filePath.Value, @"\.bd$", RegexOptions.IgnoreCase)) {
                    // It is a block design file, copy its folder to /bd
                    dag.type = SourceType.BD;
                }

                else if (fileSetType.Equals("DesignSrcs", StringComparison.OrdinalIgnoreCase)
                    && Regex.IsMatch(filePath.Value, @"\.(vhd|vhdl|v|sv)$", RegexOptions.IgnoreCase)) {
                    // It is an hdl design file (VHDL, Verilog, SystemVerilog), copy it to /rtl
                    dag.type = SourceType.RTL;
                }

                else if (fileSetType.Equals("DesignSrcs", StringComparison.OrdinalIgnoreCase)
                    && Regex.IsMatch(filePath.Value, @"\.(coe|mem|mif)$", RegexOptions.IgnoreCase)) {
                    // It is a coefficient/memory init file, copy it to /coe
                    dag.type = SourceType.COE;
                }

                else {
                    // It is any other file, copy it to /other if it was not already
                    // planned to be copied under some ip or bd
                    dag.type = SourceType.OTHER;
                }

                sources.Add(dag);

                Log("Source file is mentioned (" + dag.type.ToString("g") +"): " + dag.sourceFA);
            }

            return 0;
        }

        private void RemoveRefXcis() {
            for (int i = 0; i < sources.Count; i++) {
                VDag xcixDag = sources[i];

                if (xcixDag.type != SourceType.IP_XCIX) {
                    continue;
                }

                if (xcixDag.isLost) {
                    continue;
                }

                for (int j = 0; j < sources.Count; j++) {
                    VDag xciDag = sources[j];

                    if (xciDag.type != SourceType.IP) {
                        continue;
                    }

                    // Case-insensitive karşılaştırma: .xci + 'x' == .xcix
                    if (!string.Equals(xciDag.name + 'x', xcixDag.name, StringComparison.OrdinalIgnoreCase)) {
                        continue;
                    }

                    string xcixDir = Directory.GetParent(xcixDag.sourceFA).FullName;
                    string xciDir = Directory.GetParent(Directory.GetParent(xciDag.sourceFA).FullName).FullName;

                    if (PathsEqual(xciDir, xcixDir)) {
                        sources.Remove(xciDag);
                        xciDag.fileNode.ParentNode.RemoveChild(xciDag.fileNode);
                        if (j < i) i--;
                        Log("Ref xci is removed: " + xciDag.sourceFA);
                        break;
                    }
                }
            }
        }

        private void CreateSurrogates() {
            for (int i = 0; i < sources.Count; i++) {
                VDag dag = sources[i];
                if (dag.type != SourceType.IP_XCIX) {
                    continue;
                }

                if (dag.isLost) {
                    continue;
                }

                VDag sDag = new VDag();
                sDag.type = SourceType.IP;
                sDag.actual = dag;
                sDag.isSurrogate = true;

                using (ZipStorer zip = ZipStorer.Open(dag.sourceFA, FileAccess.Read)) {
                    List<ZipStorer.ZipFileEntry> dir = zip.ReadCentralDir();
                    List<ZipStorer.ZipFileEntry> xciCadets2 = dir.ToList();
                    List<ZipStorer.ZipFileEntry> xciCadets = dir.Where((ZipStorer.ZipFileEntry e) => {
                        return e.FilenameInZip.EndsWith(".xci", StringComparison.OrdinalIgnoreCase)
                            && e.FilenameInZip.Split('/').Length == 2; 
                    }).ToList();

                    if (xciCadets.Count == 0) {
                        sDag.isLost = true;
                        sDag.actual.isLost = true;
                        continue;
                    }

                    // En çok eşleşen prefix'i seç (descending - en yüksek puan önce)
                    xciCadets.Sort(new Comparison<ZipStorer.ZipFileEntry>((ZipStorer.ZipFileEntry e1, ZipStorer.ZipFileEntry e2) => {
                        string cadet1 = e1.FilenameInZip.Split('/')[1];
                        string cadet2 = e2.FilenameInZip.Split('/')[1];

                        int pts1, pts2;

                        for (pts1 = 0; pts1 < cadet1.Length && pts1 < dag.name.Length && char.ToLowerInvariant(cadet1[pts1]) == char.ToLowerInvariant(dag.name[pts1]); pts1++);
                        for (pts2 = 0; pts2 < cadet2.Length && pts2 < dag.name.Length && char.ToLowerInvariant(cadet2[pts2]) == char.ToLowerInvariant(dag.name[pts2]); pts2++);

                        return pts2 - pts1;  // Descending: en çok eşleşen önce
                    }));

                    ZipStorer.ZipFileEntry xciEntry = xciCadets[0];

                    string filename = xciEntry.FilenameInZip;
                    sDag.name = filename.Substring(filename.IndexOf('/') + 1);
                }

                // Case-insensitive .xcix -> klasör path dönüşümü
                sDag.sourceFA = Regex.Replace(dag.sourceFA, @"\.xcix$", "", RegexOptions.IgnoreCase) + '\\' + sDag.name;
                sDag.fileNode = dag.fileNode;
                dag.fileNode = null;
                dag.isCopied = false;
                dag.hasSurrogate = true;

                sources.RemoveAt(i);
                sources.Insert(i, sDag);
            }
        }

        private void FindIpsFromBds() {
            List<VDag> newSources = new List<VDag>();

            foreach (VDag dag in sources) {
                if (dag.type != SourceType.BD) {
                    continue;
                }

                if (dag.isLost) {
                    continue;
                }

                Log("Processing BD: " + dag.name);
                Log("  Source: " + dag.sourceFA);

                // BD klasörü gerçekten var mı kontrol et
                string bdDir = Directory.GetParent(dag.sourceFA).FullName;
                if (!Directory.Exists(bdDir)) {
                    Log("ERROR - BD directory not found");
                    Log("  Expected directory: " + bdDir);
                    Log("  BD file: " + dag.sourceFA);
                    dag.isLost = true;
                    continue;
                }
                
                Log("  BD directory: " + bdDir);

                List<string> newIpNames = new List<string>();
                
                try {
                    StreamReader bdFile = new StreamReader(dag.sourceFA); 

                    if (bdFile.Read() == '{') {
                        string line;

                        while ((line = bdFile.ReadLine()) != null) {
                            if (line.Contains("xci_name")) {
                                int s1 = line.IndexOf('"', line.IndexOf(':')) + 1;
                                int s2 = line.LastIndexOf('"');
                                if (s1 > 0 && s2 > s1) {
                                    newIpNames.Add(line.Substring(s1, s2 - s1));
                                }
                            }
                        }
                        bdFile.Close();
                    }

                    else {
                        bdFile.Close();
                        XmlDocument bdDoc;
                        XmlNamespaceManager manager = new XmlNamespaceManager(new NameTable());
                        manager.AddNamespace("spirit", "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009");
                        bdDoc = new XmlDocument();
                        bdDoc.PreserveWhitespace = true;
                        bdDoc.Load(dag.sourceFA);

                        foreach (XmlNode ipNode in bdDoc.SelectNodes("//spirit:configurableElementValue[@spirit:referenceId='bd:xciName']", manager)) {
                            if (!string.IsNullOrEmpty(ipNode.InnerText)) {
                                newIpNames.Add(ipNode.InnerText);
                            }
                        }
                    }
                }
                catch (Exception ex) {
                    Log("Warning - Could not parse BD file: " + dag.sourceFA);
                    Log("Exception: " + ex.Message);
                    continue;
                }

                // BD klasöründeki ip klasörünü bul - bu gerçek kaynak lokasyonu
                string bdIpDir = bdDir + "\\ip";
                
                foreach (string ipName in newIpNames) {
                    // Kaynak FA: BD klasörü içindeki ip klasörü
                    string potentialSourceFA = bdIpDir + "\\" + ipName + "\\" + ipName + ".xci";
                    
                    // DEDUPE: Bu IP zaten sources listesinde var mı kontrol et
                    bool alreadyExists = sources.Any(existing => 
                        existing.type == SourceType.IP && 
                        PathsEqual(existing.sourceFA, potentialSourceFA));
                    
                    if (alreadyExists) {
                        Log("Skipping duplicate BD IP (already in XPR): " + potentialSourceFA);
                        continue;
                    }
                    
                    // Create a DAG
                    VDag ipDag = new VDag();
                    ipDag.name = ipName;
                    ipDag.carrier = dag;
                    ipDag.isCarried = true;
                    ipDag.carrierRelativeLocation = "\\ip\\" + ipDag.name;
                    ipDag.name = ipDag.name + ".xci";
                    ipDag.sourceFA = potentialSourceFA;
                    
                    // IP gerçekten var mı kontrol et
                    if (!File.Exists(potentialSourceFA)) {
                        Log("Warning - BD IP not found (will be regenerated): " + potentialSourceFA);
                        ipDag.isLost = true;
                    }
                    
                    ipDag.fileNode = null;
                    ipDag.type = SourceType.IP;
                    ipDag.isCopied = false;  // BD ile birlikte kopyalanacak

                    newSources.Add(ipDag);
                    Log("Source file is mentioned in BD (" + ipDag.type.ToString("g") + "): " + ipDag.sourceFA);
                }

                // BD klasörü altındaki diğer dosyaları (XDC, DCP vb.) bul ve işaretle
                LinkBdSubFilesToBd(dag, bdDir);
            }

            sources.AddRange(newSources);
        }

        /// <summary>
        /// BD klasörü altındaki dosyalara (XDC, DCP vb.) XPR'de ayrı referans varsa
        /// bu dosyaları BD ile birlikte taşınacak şekilde işaretler ve XPR yollarını günceller.
        /// </summary>
        private void LinkBdSubFilesToBd(VDag bdDag, string bdDir) {
            Log("  Checking for BD sub-files in: " + bdDir);
            int linkedCount = 0;
            
            // BD klasörü altındaki tüm dosyaları bul (recursive)
            // XPR'de bu dosyalara referans var mı kontrol et
            foreach (VDag dag in sources) {
                // Kendisini atlat
                if (dag == bdDag || dag.isLost) {
                    continue;
                }

                // Zaten taşınan dosyaları atlat
                if (dag.isCarried) {
                    continue;
                }

                // BD dosyasını temsil eden dag'ı atlat
                if (dag.type == SourceType.BD) {
                    continue;
                }

                // BD klasörü altında mı kontrol et
                if (!IsSubPath(dag.sourceFA, bdDir)) {
                    continue;
                }

                // Bu dosya BD klasörü altında - BD ile birlikte taşınacak şekilde işaretle
                dag.isCarried = true;
                dag.carrier = bdDag;
                dag.isCopied = false;  // BD ile birlikte kopyalanacak, ayrıca kopyalanmayacak
                
                // BD klasörüne göre göreceli konum hesapla
                // Dosya yolundan BD klasörü yolunu çıkar, sonra dosya adını çıkar (sadece klasör yolu)
                string relativeFilePath = dag.sourceFA.Substring(bdDir.Length).TrimStart('\\', '/');
                string relativeDir = Path.GetDirectoryName(relativeFilePath);
                
                // Eğer dosya doğrudan BD klasöründe ise relativeDir boş olur
                if (string.IsNullOrEmpty(relativeDir) || relativeDir == "\\" || relativeDir == "/") {
                    dag.carrierRelativeLocation = "";
                } else {
                    dag.carrierRelativeLocation = "\\" + relativeDir;
                }
                
                linkedCount++;
                Log("    Linked BD sub-file: " + dag.name);
                Log("      Source: " + dag.sourceFA);
                Log("      Type: " + dag.type.ToString());
                Log("      Relative dir: " + (string.IsNullOrEmpty(dag.carrierRelativeLocation) ? "(root)" : dag.carrierRelativeLocation));
                Log("      Target will be: " + dag.targetFA);
            }
            
            if (linkedCount > 0) {
                Log("  Total " + linkedCount + " sub-files linked to BD: " + bdDag.name);
            }
        }

        /// <summary>
        /// XIT dosyalarını (subcore IP template) ana IP'lere bağlar.
        /// XIT dosyaları subcore IP'ler için Vivado tarafından oluşturulur ve 
        /// ana IP klasörü altında bulunur.
        /// </summary>
        private void LinkXitFilesToParentIp() {
            Log("Linking XIT files to parent IPs...");
            int linkedCount = 0;

            // Önce tüm XCI (ana IP) klasörlerini bul
            List<VDag> ipDags = sources.Where(d => 
                d.type == SourceType.IP && 
                !d.isLost && 
                d.sourceFA != null &&
                d.sourceFA.EndsWith(".xci", StringComparison.OrdinalIgnoreCase)
            ).ToList();

            // XIT olarak işaretlenmiş dosyaları bul
            foreach (VDag xitDag in sources.Where(d => 
                d.type == SourceType.IP && 
                !d.isLost && 
                d.sourceFA != null &&
                d.sourceFA.EndsWith(".xit", StringComparison.OrdinalIgnoreCase)
            ).ToList()) {
                
                // Bu XIT'in ana IP'sini bul - XIT, IP klasörünün alt dizininde olmalı
                string xitDir = Directory.GetParent(xitDag.sourceFA).FullName;
                
                VDag parentIp = null;
                foreach (VDag ipDag in ipDags) {
                    string ipDir = Directory.GetParent(ipDag.sourceFA).FullName;
                    
                    // XIT dosyası bu IP klasörünün altında mı?
                    if (IsSubPath(xitDag.sourceFA, ipDir)) {
                        parentIp = ipDag;
                        break;
                    }
                }

                if (parentIp != null) {
                    // XIT'i ana IP ile taşınacak şekilde işaretle
                    string ipDir = Directory.GetParent(parentIp.sourceFA).FullName;
                    string relativeFilePath = xitDag.sourceFA.Substring(ipDir.Length).TrimStart('\\', '/');
                    string relativeDir = Path.GetDirectoryName(relativeFilePath);
                    
                    xitDag.isCarried = true;
                    xitDag.carrier = parentIp;
                    xitDag.isCopied = false;  // Ana IP ile kopyalanacak
                    
                    if (string.IsNullOrEmpty(relativeDir) || relativeDir == "\\" || relativeDir == "/") {
                        xitDag.carrierRelativeLocation = "";
                    } else {
                        xitDag.carrierRelativeLocation = "\\" + relativeDir;
                    }
                    
                    linkedCount++;
                    Log("  Linked XIT to parent IP: " + xitDag.name + " -> " + parentIp.name);
                    Log("    XIT path: " + xitDag.sourceFA);
                    Log("    Parent IP: " + parentIp.sourceFA);
                    Log("    Relative location: " + (string.IsNullOrEmpty(xitDag.carrierRelativeLocation) ? "(root)" : xitDag.carrierRelativeLocation));
                } else {
                    // Ana IP bulunamadı - XIT'i bağımsız olarak kopyala
                    Log("  Warning - No parent IP found for XIT: " + xitDag.name);
                    Log("    XIT path: " + xitDag.sourceFA);
                    // XIT dosyasını OTHER olarak değiştir - ayrı kopyalanacak
                    xitDag.type = SourceType.OTHER;
                }
            }
            
            Log("XIT linking complete: " + linkedCount + " files linked");
        }

        private void FindCoesForIps() {
            foreach (VDag dag in sources) {
                if (dag.type != SourceType.IP) {
                    continue;
                }

                if (dag.isLost) {
                    continue;
                }

                XmlDocument xciDoc;

                if (dag.isSurrogate) {
                    using (ZipStorer zip = ZipStorer.Open(dag.actual.sourceFA, FileAccess.Read)) {
                        List<ZipStorer.ZipFileEntry> dir = zip.ReadCentralDir();
                        List<ZipStorer.ZipFileEntry> xciCadets2 = dir.ToList();
                        List<ZipStorer.ZipFileEntry> xciCadets = dir.Where((ZipStorer.ZipFileEntry e) => {
                            return e.FilenameInZip.EndsWith(".xci", StringComparison.OrdinalIgnoreCase);
                        }).ToList();
                        xciCadets.Sort(new Comparison<ZipStorer.ZipFileEntry>((ZipStorer.ZipFileEntry e1, ZipStorer.ZipFileEntry e2) => {
                            return e1.FilenameInZip.CompareTo(e2.FilenameInZip);
                        }));

                        if (xciCadets.Count > 0) {
                            ZipStorer.ZipFileEntry xciEntry = xciCadets[0];

                            MemoryStream ms = new MemoryStream();
                            zip.ExtractFile(xciEntry, ms);

                            xciDoc = new XmlDocument();
                            xciDoc.PreserveWhitespace = true;
                            string content = System.Text.Encoding.UTF8.GetString(ms.ToArray());
                            xciDoc.Load(new StringReader(content));
                        }

                        else {
                            dag.isLost = true;
                            dag.actual.isLost = true;
                            xciDoc = null;
                            continue;
                        }
                    }
                }

                else {
                    xciDoc = new XmlDocument();
                    xciDoc.PreserveWhitespace = true;
                    xciDoc.Load(dag.sourceFA);
                }

                XmlNamespaceManager manager = new XmlNamespaceManager(new NameTable());
                manager.AddNamespace("spirit", "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009");
                XmlNode node;

                node = xciDoc.SelectSingleNode("//spirit:configurableElementValue[@spirit:referenceId='PARAM_VALUE.Coe_File']", manager);

                if (node == null) {
                    node = xciDoc.SelectSingleNode("//spirit:configurableElementValue[@spirit:referenceId='PARAM_VALUE.MemInitFile']", manager);
                }

                if (node == null) {
                    continue;
                }

                // node.FirstChild null olabilir - boş değer
                if (node.FirstChild == null || string.IsNullOrEmpty(node.FirstChild.Value)) {
                    continue;
                }

                string nodeStr = node.FirstChild.Value;
                string absolutePath = TraversePath(nodeStr, dag.copiedFA);

                if (absolutePath == "%invalid%") {
                    continue;
                }

                VDag cDag = sources.FirstOrDefault(delegate (VDag cand) {
                    return cand.type == SourceType.COE && PathsEqual(absolutePath, cand.sourceFA);
                });

                if (cDag == null) {
                    continue;
                }

                if (IsSubPath(cDag.sourceFA, dag.copiedFA)) {
                    cDag.isCopied = false;
                    cDag.isCarried = true;
                    cDag.carrier = dag;
                    string relativeFilePath = cDag.copiedFA.Substring(dag.copiedFA.Length).TrimStart('\\', '/');
                    string relativeDir = Path.GetDirectoryName(relativeFilePath);
                    if (string.IsNullOrEmpty(relativeDir) || relativeDir == "\\" || relativeDir == "/") {
                        cDag.carrierRelativeLocation = "";
                    } else {
                        cDag.carrierRelativeLocation = "\\" + relativeDir;
                    }
                }

                else {
                    dag.affector.Add(cDag);
                }
            }
        }

        private void ResolveCopyOrder() {
            foreach (VDag dag in sources) {
                foreach (VDag pDag in sources) {
                    if (dag.isLost) {
                        continue;
                    }
                    if (pDag.isLost) {
                        continue;
                    }

                    // Aynı dosyanın kendisini beklemesini engelle (self-dependency)
                    if (ReferenceEquals(dag, pDag) || PathsEqual(dag.copiedFA, pDag.copiedFA)) {
                        continue;
                    }

                    if (IsSubPath(dag.copiedFA, pDag.copiedFA)) {
                        pDag.dagsToWaitCopied.Add(dag);
                    }
                }
            }
        }

        private int ResolveMatchingNames() {
            // Grupla: (type, name_) -> aynı isimdeki DAG'lar
            // Stabil sıralama için sourceFA'ya göre sırala, sonra deterministik sayaç ata
            var groups = new Dictionary<string, List<VDag>>();
            
            foreach (VDag dag in sources) {
                if (dag.isLost) continue;
                
                // name_ kullan (knownIdentical'den etkilenmemiş orijinal isim)
                string key = dag.type.ToString() + "|" + dag.name_;
                if (!groups.ContainsKey(key)) {
                    groups[key] = new List<VDag>();
                }
                groups[key].Add(dag);
            }
            
            foreach (var kvp in groups) {
                List<VDag> group = kvp.Value;
                if (group.Count <= 1) continue;
                
                // Duplicate path kontrolü
                for (int i = 0; i < group.Count; i++) {
                    for (int j = i + 1; j < group.Count; j++) {
                        if (PathsEqual(group[i].sourceFA, group[j].sourceFA)) {
                            Log("ERROR - Duplicate references in xpr file:\n"
                                + group[i].sourceFA + '\n'
                                + group[j].sourceFA);
                            return ERRORCODE_INVALID_PROJECT_FILE;
                        }
                    }
                }
                
                // Stabil sıralama: sourceFA'ya göre (deterministik)
                group.Sort((a, b) => string.Compare(a.sourceFA, b.sourceFA, StringComparison.OrdinalIgnoreCase));
                
                // Deterministik sayaç ata: ilk dosya 1, ikinci 2, ...
                for (int i = 0; i < group.Count; i++) {
                    group[i].knownIdentical = i + 1;
                }
            }

            return 0;
        }

        private void DoMigration() {
            int i = 0;
            int totalToCopy = sources.Count(dag => !dag.wasCopied && dag.isCopied && !dag.isLost);
            int copiedCount = 0;
            int maxIterations = sources.Count * sources.Count + 1000; // Sonsuz döngü koruması
            int iterations = 0;

            Log("  Starting copy of " + totalToCopy + " files...\n");

            while (sources.Any(delegate (VDag dag) {return !dag.wasCopied && dag.isCopied && !dag.isLost;})) {
                iterations++;
                if (iterations > maxIterations) {
                    Log("ERROR - DoMigration appears stuck, breaking loop after " + iterations + " iterations\n");
                    // Hangi dosyalar kopyalanamadı?
                    foreach (VDag stuck in sources.Where(d => !d.wasCopied && d.isCopied && !d.isLost)) {
                        Log("  Stuck file: " + stuck.name + " waiting for " + stuck.dagsToWaitCopied.Count(w => !w.wasCopied && w.isCopied) + " dependencies\n");
                    }
                    break;
                }

                VDag dag = sources[i];
                i = (i + 1) % sources.Count;

                if (dag.wasCopied || !dag.isCopied) {
                    continue;
                }

                if (!dag.dagsToWaitCopied.TrueForAll(delegate (VDag cDag) { return cDag.wasCopied || !cDag.isCopied; })) {
                    continue;
                }

                copiedCount++;
                Log("  [" + copiedCount + "/" + totalToCopy + "] Copying: " + dag.name + "\n");
                MigrateDag(dag);
            }

            Log("  Copy complete: " + copiedCount + " files\n");
        }

        private void MigrateDag(VDag dag) {
            // MAX_PATH kontrolü (Windows limiti 260 karakter)
            if (dag.targetLocation.Length >= 260) {
                Log("Warning - Target path exceeds MAX_PATH (260 chars): " + dag.targetLocation);
                Log("Warning - Path length: " + dag.targetLocation.Length + " characters");
            }

            try {
                if (dag.isSurrogate) {
                    // XCIX'den sadece XCI dosyasını çıkar - diğer artifactleri atla
                    UnzipXciOnly(dag.actual.sourceFA, Directory.GetParent(dag.targetLocation).FullName, dag.name);
                }

                else if (dag.isRepresentingItsFolder) {
                    // IP klasörleri için sadece XCI dosyasını kopyala - Vivado gerisini üretir
                    if (dag.type == SourceType.IP) {
                        CopyOnlyXci(dag.copiedFA, dag.targetLocation);
                    }
                    // BD klasörleri için minimal kopyalama - XDC dahil
                    else if (dag.type == SourceType.BD) {
                        DirectoryCopyMinimalForBD(dag.copiedFA, dag.targetLocation);
                    }
                    else {
                        DirectoryCopy(dag.copiedFA, dag.targetLocation);
                    }
                }

                else {
                    // Normal dosyalar için hedef klasörü oluştur
                    string targetDir = Path.GetDirectoryName(dag.targetLocation);
                    if (!string.IsNullOrEmpty(targetDir) && !Directory.Exists(targetDir)) {
                        Directory.CreateDirectory(targetDir);
                    }
                    File.Copy(dag.copiedFA, dag.targetLocation);
                }

                Log("Copy/unzip source: " + dag.copiedFA);
                dag.wasCopied = true;
            }

            catch (Exception e) {
                Log("ERROR - Could not copy/unzip source");
                Log("  File name: " + dag.name);
                Log("  File type: " + dag.type.ToString());
                Log("  Source path: " + dag.copiedFA);
                Log("  Target location: " + dag.targetLocation);
                Log("  Target file: " + dag.targetFA);
                Log("  Is carried: " + dag.isCarried);
                if (dag.isCarried && dag.carrier != null) {
                    Log("  Carrier: " + dag.carrier.name);
                    Log("  Carrier relative location: " + dag.carrierRelativeLocation);
                }
                Log("  Is representing folder: " + dag.isRepresentingItsFolder);
                Log("  Is surrogate: " + dag.isSurrogate);
                Log("  Exception type: " + e.GetType().Name);
                Log("  Exception message: " + e.Message);
                if (e.InnerException != null) {
                    Log("  Inner exception: " + e.InnerException.Message);
                }
                dag.wasCopied = false;
                dag.isLost = true;  // Dosya kayboldu olarak işaretle
            }
        }

        private void CopyIpRepo(string ipRepoPathFromXpr) {
            try {
                if (string.IsNullOrEmpty(ipRepoPathFromXpr)) {
                    return;
                }

                string[] repoEntries = ipRepoPathFromXpr
                    .Split(new char[] { ';' }, StringSplitOptions.RemoveEmptyEntries);

                HashSet<string> repoPaths = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
                foreach (string entry in repoEntries) {
                    string trimmed = entry.Trim().Trim('"');
                    if (string.IsNullOrEmpty(trimmed)) {
                        continue;
                    }

                    string ipRepoPath = ConvertPathXPRtoMSW(trimmed);
                    if (ipRepoPath == "%invalid%") {
                        Log("Warning - IP Repo path invalid: " + trimmed);
                        continue;
                    }

                    if (!Directory.Exists(ipRepoPath)) {
                        Log("Warning - IP Repo path not found: " + ipRepoPath);
                        continue;
                    }

                    string normalized = NormalizePath(ipRepoPath);
                    repoPaths.Add(normalized);
                }

                if (repoPaths.Count == 0) {
                    return;
                }

                string targetCustomRepo = FolderStructure.AbsoluteDir(SourceType.IP) + "\\custom_ip_repo";
                Directory.CreateDirectory(targetCustomRepo);

                bool useRepoSubDirs = repoPaths.Count > 1;
                HashSet<string> usedRepoNames = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
                HashSet<string> copiedIpDirs = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
                HashSet<string> usedTargetDirs = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
                List<string> newRepoPaths = new List<string>();

                foreach (string repoPath in repoPaths) {
                    string targetRoot = targetCustomRepo;

                    if (useRepoSubDirs) {
                        string repoName = new DirectoryInfo(repoPath).Name;
                        string repoTargetName = EnsureUniqueName(repoName, usedRepoNames);
                        targetRoot = Path.Combine(targetCustomRepo, repoTargetName);
                        newRepoPaths.Add("$PPRDIR/../ip/custom_ip_repo/" + repoTargetName);
                    }
                    else if (newRepoPaths.Count == 0) {
                        newRepoPaths.Add("$PPRDIR/../ip/custom_ip_repo");
                    }

                    Log("Copying Custom IP Repo: " + repoPath);
                    Directory.CreateDirectory(targetRoot);

                    FindAndCopyCustomIps(repoPath, targetRoot, copiedIpDirs, usedTargetDirs);
                }

                Log("Copied Custom IP Repo to: " + targetCustomRepo);

                XmlNode ipRepoNode = projectDoc.SelectSingleNode("/Project/Configuration/Option[@Name='IPRepoPath']");
                if (ipRepoNode != null && newRepoPaths.Count > 0) {
                    string newPath = string.Join(";", newRepoPaths.Distinct(StringComparer.OrdinalIgnoreCase).ToArray());
                    ipRepoNode.Attributes["Val"].Value = newPath;
                    Log("Updated IP Repo path in XPR: " + newPath);
                }
            }
            catch (Exception ex) {
                Log("Warning - Error while copying IP Repo: " + ex.Message);
            }
        }

        /// <summary>
        /// IP ve BD klasörleri için minimal kopyalama - sadece kaynak dosyaları alır
        /// DCP, sim_netlist gibi Vivado tarafından üretilen dosyaları hariç tutar
        /// NOT: .xml dosyaları TUTULMALI - component.xml ve interface tanımları için gerekli!
        /// NOT: BD için .xdc dosyaları TUTULMALI - BD constraint dosyaları!
        /// </summary>
        private void DirectoryCopyMinimal(string sourceDir, string destDir) {
            DirectoryCopyMinimalInternal(sourceDir, destDir, false);
        }

        /// <summary>
        /// BD klasörleri için minimal kopyalama - XDC dahil, DCP hariç (Vivado yeniden üretir)
        /// </summary>
        private void DirectoryCopyMinimalForBD(string sourceDir, string destDir) {
            DirectoryCopyMinimalInternal(sourceDir, destDir, true);
        }

        private void DirectoryCopyMinimalInternal(string sourceDir, string destDir, bool isBD) {
            DirectoryInfo dir = new DirectoryInfo(sourceDir);
            
            if (!dir.Exists) {
                Log("ERROR - Source directory not found for minimal copy");
                Log("  Source: " + sourceDir);
                Log("  Target: " + destDir);
                Log("  Is BD: " + isBD);
                return;
            }

            // Vivado tarafından üretilen ve hariç tutulacak dosya PATTERN'leri
            string[] excludePatterns = new string[] {
                "_sim_netlist.v",     // Simülasyon netlist
                "_sim_netlist.vhdl",
                "_stub.v",            // Stub dosyaları
                "_stub.vhdl",
                "_wrapper.v",         // Wrapper - hdl'de zaten var
                "_wrapper.vhd",
            };
            
            // Hariç tutulacak uzantılar - DCP her zaman hariç (Vivado yeniden üretir)
            string[] excludeExtensions = new string[] {
                ".dcp",           // Design checkpoint - sentez çıktısı
                ".hwdef",         // Hardware definition
                ".sysdef",        // System definition
            };
            
            // Hariç tutulacak klasörler - Vivado tarafından üretilir
            // NOT: ipshared TUTULMALI - custom IP dosyaları için gerekli!
            // BD için hw_handoff ve hdl klasörleri de TUTULMALI!
            string[] excludeDirs = isBD ? new string[] {
                "sim",            // Simülasyon çıktıları
            } : new string[] {
                "sim",            // Simülasyon çıktıları
                "synth",          // Sentez çıktıları
            };

            Directory.CreateDirectory(destDir);
            DirectoryInfo[] dirsIn = dir.GetDirectories();
            FileInfo[] filesIn = dir.GetFiles();

            foreach (FileInfo file in filesIn) {
                // Hariç tutulan pattern'leri kontrol et
                bool exclude = false;
                
                // Önce pattern'leri kontrol et
                foreach (string pattern in excludePatterns) {
                    if (file.Name.EndsWith(pattern, StringComparison.OrdinalIgnoreCase)) {
                        exclude = true;
                        break;
                    }
                }
                
                // Sonra uzantıları kontrol et
                if (!exclude) {
                    foreach (string ext in excludeExtensions) {
                        if (file.Name.EndsWith(ext, StringComparison.OrdinalIgnoreCase)) {
                            exclude = true;
                            break;
                        }
                    }
                }
                
                if (!exclude) {
                    string tempPath = Path.Combine(destDir, file.Name);
                    try {
                        file.CopyTo(tempPath);
                    }
                    catch (Exception ex) {
                        Log("Warning - Could not copy file: " + file.FullName + " - " + ex.Message);
                    }
                }
            }

            foreach (DirectoryInfo dirIn in dirsIn) {
                // Hariç tutulan klasörleri atla
                if (!excludeDirs.Contains(dirIn.Name, StringComparer.OrdinalIgnoreCase)) {
                    string tempPath = Path.Combine(destDir, dirIn.Name);
                    DirectoryCopyMinimalInternal(dirIn.FullName, tempPath, isBD);
                }
            }
        }

        /// <summary>
        /// IP klasörü için XCI ve COE dosyalarını kopyala
        /// Vivado XCI'dan IP'yi yeniden üretir, ancak COE dosyaları gerekli
        /// </summary>
        private void CopyOnlyXci(string sourceDir, string destDir) {
            DirectoryInfo dir = new DirectoryInfo(sourceDir);
            
            if (!dir.Exists) {
                return;
            }

            Directory.CreateDirectory(destDir);
            
            // XCI, XIT, XML, COE ve MEM dosyalarını kopyala
            // XML dosyaları kritik - IP configuration ve component tanımları için gerekli
            foreach (FileInfo file in dir.GetFiles()) {
                string ext = file.Extension.ToLowerInvariant();
                if (ext == ".xci" || ext == ".xit" || ext == ".xml" || ext == ".coe" || ext == ".mem") {
                    string targetPath = Path.Combine(destDir, file.Name);
                    try {
                        file.CopyTo(targetPath);
                        Log("Copied " + ext.ToUpper().Substring(1) + ": " + file.Name);
                    }
                    catch (Exception ex) {
                        Log("Warning - Could not copy " + ext + ": " + file.FullName + " - " + ex.Message);
                    }
                }
            }
            
            // Alt klasörlerde de COE dosyası olabilir - recursive ara
            foreach (DirectoryInfo subDir in dir.GetDirectories()) {
                // sim, synth gibi üretilen klasörleri atla
                if (subDir.Name.Equals("sim", StringComparison.OrdinalIgnoreCase) ||
                    subDir.Name.Equals("synth", StringComparison.OrdinalIgnoreCase)) {
                    continue;
                }
                CopyOnlyXciRecursive(subDir.FullName, Path.Combine(destDir, subDir.Name));
            }
        }
        
        /// <summary>
        /// Alt klasörlerde XCI, COE ve MEM dosyalarını recursive kopyala
        /// Subcore IP'lerin XCI dosyaları da dahil!
        /// </summary>
        private void CopyOnlyXciRecursive(string sourceDir, string destDir) {
            DirectoryInfo dir = new DirectoryInfo(sourceDir);
            if (!dir.Exists) return;
            
            bool hasFiles = false;
            foreach (FileInfo file in dir.GetFiles()) {
                string ext = file.Extension.ToLowerInvariant();
                // XCI (subcore), XIT, XML, COE ve MEM dosyalarını kopyala
                // XML dosyaları subcore için de gerekli olabilir
                if (ext == ".xci" || ext == ".xit" || ext == ".xml" || ext == ".coe" || ext == ".mem") {
                    if (!hasFiles) {
                        Directory.CreateDirectory(destDir);
                        hasFiles = true;
                    }
                    try {
                        string targetPath = Path.Combine(destDir, file.Name);
                        if (!File.Exists(targetPath)) {
                            file.CopyTo(targetPath);
                            Log("Copied " + ext.ToUpper().Substring(1) + " (subcore): " + file.Name);
                        }
                    }
                    catch (Exception ex) {
                        Log("Warning - Could not copy subcore file: " + file.Name + " - " + ex.Message);
                    }
                }
            }
            
            foreach (DirectoryInfo subDir in dir.GetDirectories()) {
                if (subDir.Name.Equals("sim", StringComparison.OrdinalIgnoreCase) ||
                    subDir.Name.Equals("synth", StringComparison.OrdinalIgnoreCase)) {
                    continue;
                }
                CopyOnlyXciRecursive(subDir.FullName, Path.Combine(destDir, subDir.Name));
            }
        }

        private void WalkDags() {
            // Remove core container tags
            foreach (VDag dag in sources.Where(delegate (VDag dag) {
                return dag.type == SourceType.IP && !dag.isLost;
            })) {
                if (!File.Exists(dag.targetFA)) {
                    Log("Warning - IP file not found for update: " + dag.targetFA);
                    continue;
                }

                try {
                    XmlDocument xciDoc;
                    xciDoc = new XmlDocument();
                    xciDoc.PreserveWhitespace = true;
                    xciDoc.Load(dag.targetFA);
                    XmlNamespaceManager manager = new XmlNamespaceManager(new NameTable());
                    manager.AddNamespace("spirit", "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009");
                    XmlNode node;

                    // Update xci to disable core container, if enabled
                    node = xciDoc.SelectSingleNode("//spirit:configurableElementValue[@spirit:referenceId='RUNTIME_PARAM.CORECONTAINER']", manager);

                    if (node != null) {
                        XmlNode parentNode = node.ParentNode;
                        parentNode.RemoveChild(node);
                        Log("Removed core container configuration from ip: " + dag.name);
                        using (XmlWriter writer = XmlWriter.Create(dag.targetFA)) {
                            xciDoc.WriteTo(writer);
                        }
                    }
                }
                catch (Exception ex) {
                    Log("WARNING - Could not process IP file for core container update");
                    Log("  IP file: " + dag.targetFA);
                    Log("  IP name: " + dag.name);
                    Log("  Exception type: " + ex.GetType().Name);
                    Log("  Exception message: " + ex.Message);
                }
            }

            // Update relative locations of coes in ip xcis and xmls
            foreach (VDag dag in sources.Where(delegate (VDag dag) {
                return dag.type == SourceType.IP && !dag.isLost;
            })) {
                foreach (VDag cDag in dag.affector.Where(delegate (VDag cDag) {
                    return cDag.type == SourceType.COE;// && !cDag.isLost; // Update relative location even if coe is lost
                })) {
                    if (!File.Exists(dag.targetFA)) {
                        Log("Warning - IP file not found for COE update: " + dag.targetFA);
                        continue;
                    }

                    try {
                        XmlDocument xciDoc;
                        xciDoc = new XmlDocument();
                        xciDoc.PreserveWhitespace = true;
                        xciDoc.Load(dag.targetFA);
                        XmlNamespaceManager manager = new XmlNamespaceManager(new NameTable());
                        manager.AddNamespace("spirit", "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009");
                        XmlNode node;

                        node = xciDoc.SelectSingleNode("//spirit:configurableElementValue[@spirit:referenceId='PARAM_VALUE.Coe_File']", manager);

                        if (node == null) {
                            node = xciDoc.SelectSingleNode("//spirit:configurableElementValue[@spirit:referenceId='PARAM_VALUE.MemInitFile']", manager);
                        }

                        if (node == null) {
                            continue;
                        }

                        // node.FirstChild null olabilir
                        if (node.FirstChild == null) {
                            continue;
                        }

                        node.FirstChild.Value = RelativizePath(cDag.targetFA, dag.targetLocation).Replace('\\', '/'); 

                        using (XmlWriter writer = XmlWriter.Create(dag.targetFA)) {
                            xciDoc.WriteTo(writer);
                        }

                        Log("Changed relative location for coe - in xci: " + cDag.name + " - " + dag.name);

                        string xmlFile = dag.targetFA.Substring(0, dag.targetFA.Length - 4) + ".xml";

                        if (!File.Exists(xmlFile)) {
                            continue;
                        }

                        XmlDocument xmlDoc;
                        xmlDoc = new XmlDocument();
                        xmlDoc.PreserveWhitespace = true;
                        xmlDoc.Load(xmlFile);

                        node = xmlDoc.SelectSingleNode("//spirit:value[@spirit:id='PARAM_VALUE.Coe_File']", manager);

                        if (node == null) {
                            node = xmlDoc.SelectSingleNode("//spirit:value[@spirit:id='PARAM_VALUE.MemInitFile']", manager);
                        }

                        if (node == null) {
                            continue;
                        }

                        // node.FirstChild null olabilir
                        if (node.FirstChild == null) {
                            continue;
                        }

                        node.FirstChild.Value = RelativizePath(cDag.targetFA, dag.targetLocation).Replace('\\', '/');

                        using (XmlWriter writer = XmlWriter.Create(xmlFile))
                        {
                            xmlDoc.WriteTo(writer);
                        }

                        Log("Changed relative location for coe - in xml: " + cDag.name + " - " + dag.name);
                    }
                    catch (Exception ex) {
                        Log("WARNING - Could not update COE reference in IP");
                        Log("  IP file: " + dag.targetFA);
                        Log("  IP name: " + dag.name);
                        Log("  COE file: " + cDag.name);
                        Log("  Exception type: " + ex.GetType().Name);
                        Log("  Exception message: " + ex.Message);
                    }
                }
            }

            // Update the related part in the xpr file
            Log("Updating XPR file paths...");
            int updatedCount = 0;
            int removedCount = 0;
            
            foreach (VDag dag in sources.Where(delegate (VDag dag) {
                return dag.fileNode != null;
            })) {
                if (dag.isLost && dag.fileNode.ParentNode is object) {
                    dag.fileNode.ParentNode.RemoveChild(dag.fileNode);
                    warnings.Add(dag.name + " is not found, see above logs for its address");
                    removedCount++;
                    Log("  Removed lost file from XPR: " + dag.name);

                }

                else if (dag.isSurrogate) {
                    string newPath = dag.PPRRelativeFA;
                    dag.fileNode.Attributes["Path"].Value = newPath;
                    updatedCount++;
                    Log("  Updated surrogate path: " + dag.name + " -> " + newPath);
                }

                else if (!dag.hasSurrogate) {
                    string newPath = dag.PPRRelativeFA;
                    string oldPath = dag.fileNode.Attributes["Path"].Value;
                    dag.fileNode.Attributes["Path"].Value = newPath;
                    updatedCount++;
                    if (dag.isCarried) {
                        Log("  Updated carried file path: " + dag.name);
                        Log("    Old: " + oldPath);
                        Log("    New: " + newPath);
                    }
                }
            }
            
            Log("XPR update complete: " + updatedCount + " paths updated, " + removedCount + " lost files removed");
        }


        private void SaveProjectDoc() {
            using (XmlWriter writer = XmlWriter.Create(FolderStructure.workDir + '\\' + projectName + ".xpr")) {
                projectDoc.WriteTo(writer);
            }
        }

        private void CopyOutputFile(string sourcePath, string targetPath, string label) {
            if (!File.Exists(sourcePath)) {
                return;
            }

            try {
                File.Copy(sourcePath, targetPath);
                Log("Copied " + label + " file: " + sourcePath);
            }
            catch (Exception ex) {
                Log("Warning - Could not copy " + label + " file: " + ex.Message);
            }
        }

        // Look for bit files in impl_n folders, choose the latest and copy to out
        private void CopyBitFile() {
            try {
                XmlNode projectCurrentImpl = projectDoc.SelectSingleNode("//Run[starts-with(@Id,'impl') and @State='current']");

                if (projectCurrentImpl is object) {
                    string projectCurrentImplDir = projectCurrentImpl.Attributes["Dir"].Value;
                    string implDirPath = ConvertPathXPRtoMSW(projectCurrentImplDir);
                    
                    // Klasörün var olup olmadığını kontrol et
                    if (!Directory.Exists(implDirPath)) {
                        Log("Warning - Implementation directory not found: " + implDirPath);
                        return;
                    }
                    
                    string[] bitFiles = Directory.GetFiles(implDirPath, "*.bit");
                    if (bitFiles.Length == 0) {
                        Log("Warning - Bit file not found: " + implDirPath);
                        return;
                    }

                    // Pick the newest bit file if multiple outputs exist.
                    string bitFile = bitFiles[0];
                    DateTime lastWrite = File.GetLastWriteTimeUtc(bitFile);
                    for (int i = 1; i < bitFiles.Length; i++) {
                        DateTime candidateWrite = File.GetLastWriteTimeUtc(bitFiles[i]);
                        if (candidateWrite > lastWrite) {
                            bitFile = bitFiles[i];
                            lastWrite = candidateWrite;
                        }
                    }

                    string outDir = FolderStructure.AbsoluteDir(SourceType.OUT);

                    CopyOutputFile(bitFile, Path.Combine(outDir, projectName + ".bit"), "bit");
                    CopyOutputFile(Path.ChangeExtension(bitFile, ".ltx"), Path.Combine(outDir, projectName + ".ltx"), "ltx");
                    CopyOutputFile(Path.ChangeExtension(bitFile, ".mmi"), Path.Combine(outDir, projectName + ".mmi"), "mmi");
                    CopyOutputFile(Path.ChangeExtension(bitFile, ".mcs"), Path.Combine(outDir, projectName + ".mcs"), "mcs");
                }
            }
            catch (Exception ex) {
                Log("Warning - Error while copying bit file: " + ex.Message);
            }
        }

        private string ConvertPathXPRtoMSW(string path, string relativeToDir = "") {
            if (string.IsNullOrEmpty(path)) {
                return path;
            }

            string raw = path.Replace('/', '\\').Trim();
            bool hasMacro = raw.IndexOf("$PPRDIR", StringComparison.OrdinalIgnoreCase) >= 0
                || raw.IndexOf("$PSRCDIR", StringComparison.OrdinalIgnoreCase) >= 0
                || raw.IndexOf("$PIPUSERFILESDIR", StringComparison.OrdinalIgnoreCase) >= 0
                || raw.IndexOf("$PRUNDIR", StringComparison.OrdinalIgnoreCase) >= 0;

            string relative = Regex.Replace(raw, "\\$PPRDIR", "", RegexOptions.IgnoreCase);
            relative = Regex.Replace(relative, "\\$PSRCDIR", projectName + ".srcs", RegexOptions.IgnoreCase);
            relative = Regex.Replace(relative, "\\$PIPUSERFILESDIR", projectName + ".ip_user_files", RegexOptions.IgnoreCase);
            relative = Regex.Replace(relative, "\\$PRUNDIR", projectName + ".runs", RegexOptions.IgnoreCase);

            if (!hasMacro && Path.IsPathRooted(relative)) {
                // Mutlak yol var - dosya mevcut mu kontrol et
                string normalized = NormalizePath(relative);
                if (File.Exists(normalized) || Directory.Exists(normalized)) {
                    return normalized;
                }

                // Dosya bulunamadı - XPR'deki eski mutlak yoldan göreceli yol çıkarmaya çalış
                // Örnek: C:/Users/eski/Desktop/proje/RX270_KUTU.srcs/sources_1/bd/design_1.bd
                // -> RX270_KUTU.srcs/sources_1/bd/design_1.bd -> projectFileDir + RX270_KUTU.srcs/...
                string resolvedPath = TryResolveAbsolutePath(normalized);
                if (resolvedPath != null) {
                    return resolvedPath;
                }

                // Çözülemedi - orijinal yolu döndür (lost olarak işaretlenecek)
                return normalized;
            }

            string baseDir = string.IsNullOrEmpty(relativeToDir) ? projectFileDir : relativeToDir;
            string traversed = TraversePath(relative, baseDir);
            if (traversed == "%invalid%") {
                return traversed;
            }

            return NormalizePath(traversed);
        }

        /// <summary>
        /// Eski mutlak yolları proje klasörüne göre çözümlemeye çalışır.
        /// Örnek: C:/eski/proje/RX270_KUTU.srcs/bd/design.bd -> C:/yeni/proje/RX270_KUTU.srcs/bd/design.bd
        /// </summary>
        private string TryResolveAbsolutePath(string absolutePath) {
            // Bilinen proje alt klasör kalıplarını ara
            string[] knownPatterns = new string[] {
                projectName + ".srcs",
                projectName + ".ip_user_files",
                projectName + ".runs",
                projectName + ".gen",
                projectName + ".sim",
                projectName + ".cache"
            };

            foreach (string pattern in knownPatterns) {
                int idx = absolutePath.IndexOf(pattern, StringComparison.OrdinalIgnoreCase);
                if (idx > 0) {
                    // Kalıptan sonraki kısmı al
                    string relativePart = absolutePath.Substring(idx);
                    string candidatePath = Path.Combine(projectFileDir, relativePart);
                    candidatePath = NormalizePath(candidatePath);

                    if (File.Exists(candidatePath) || Directory.Exists(candidatePath)) {
                        Log("Resolved stale absolute path: " + absolutePath + " -> " + candidatePath);
                        return candidatePath;
                    }
                }
            }

            // .srcs, .runs gibi genel kalıpları da dene (farklı proje adı olabilir)
            string[] genericPatterns = new string[] { ".srcs", ".ip_user_files", ".runs", ".gen", ".sim", ".cache" };
            foreach (string suffix in genericPatterns) {
                // projectName.srcs gibi bir pattern bul
                int suffixIdx = absolutePath.IndexOf(suffix, StringComparison.OrdinalIgnoreCase);
                if (suffixIdx > 0) {
                    // suffix'ten önceki klasör adını bul
                    int slashIdx = absolutePath.LastIndexOf('\\', suffixIdx);
                    if (slashIdx < 0) slashIdx = absolutePath.LastIndexOf('/', suffixIdx);
                    if (slashIdx >= 0) {
                        string folderName = absolutePath.Substring(slashIdx + 1, suffixIdx - slashIdx - 1);
                        // Bu klasör adı proje adıyla eşleşiyor mu?
                        if (folderName.Equals(projectName, StringComparison.OrdinalIgnoreCase)) {
                            string relativePart = absolutePath.Substring(slashIdx + 1);
                            string candidatePath = Path.Combine(projectFileDir, relativePart);
                            candidatePath = NormalizePath(candidatePath);

                            if (File.Exists(candidatePath) || Directory.Exists(candidatePath)) {
                                Log("Resolved stale absolute path (generic): " + absolutePath + " -> " + candidatePath);
                                return candidatePath;
                            }
                        }
                    }
                }
            }

            return null;
        }

        private string ConvertPathMSWtoXPR(string path, bool relativeToNewDir = false) {
            return path
                .Replace((relativeToNewDir ? FolderStructure.workDir : projectFileDir), "$PPRDIR")
                .Replace((relativeToNewDir ? FolderStructure.workDir : projectFileDir) + "\\" + projectName + ".srcs", "$PSRCDIR")
                .Replace('\\', '/');
        }

        private sealed class VitisProjectInfo {
            public string SourceDir { get; set; }
            public string TargetName { get; set; }
        }

        private IEnumerable<string> EnumerateVitisCandidates() {
            // Sadece proje klasörü içinde ve yanında Vitis ara
            // Parent klasöre (örn. OLD/) BAKMA - başka projelerin Vitis'lerini alır!
            List<string> directCandidates = new List<string> {
                Path.Combine(projectFileDir, projectName + ".vitis"),
                Path.Combine(projectFileDir, "vitis"),
                Path.Combine(projectFileDir, ".vitis"),
                Path.Combine(projectFileDir, projectName + "_vitis"),
            };

            foreach (string candidate in directCandidates) {
                if (Directory.Exists(candidate)) {
                    yield return candidate;
                }
            }

            // Sadece proje klasörü içinde recursive ara (parent'a bakma!)
            HashSet<string> skipDirs = new HashSet<string>(StringComparer.OrdinalIgnoreCase) {
                ".git", ".vs", ".vscode", "work", "out", "elf", "docs",
                "ip", "bd", "hdl", "sim", "const", "managed_ip_project",
                ".Xil", "ip_user_files", "xsim.dir"
            };

            if (!string.IsNullOrEmpty(projectName)) {
                skipDirs.Add(projectName + ".srcs");
                skipDirs.Add(projectName + ".runs");
                skipDirs.Add(projectName + ".cache");
            }

            // Sadece proje klasörü içinde ara
            foreach (string dir in EnumerateDirectoriesDepth(projectFileDir, 2, skipDirs)) {
                if (LooksLikeVitisDir(dir)) {
                    yield return dir;
                }
            }
        }

        private List<VitisProjectInfo> FindVitisProjects() {
            List<VitisProjectInfo> results = new List<VitisProjectInfo>();
            HashSet<string> foundDirs = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
            HashSet<string> usedTargetNames = new HashSet<string>(StringComparer.OrdinalIgnoreCase);

            foreach (string candidate in EnumerateVitisCandidates()) {
                string normalized = NormalizePath(candidate);
                if (string.IsNullOrEmpty(normalized) || !Directory.Exists(normalized)) {
                    continue;
                }

                if (!foundDirs.Add(normalized)) {
                    continue;
                }

                string baseName = new DirectoryInfo(normalized).Name;
                string targetName = EnsureUniqueName(baseName, usedTargetNames);

                results.Add(new VitisProjectInfo {
                    SourceDir = normalized,
                    TargetName = targetName
                });
            }

            return results;
        }

        private IEnumerable<string> EnumerateDirectoriesDepth(string rootDir, int maxDepth, HashSet<string> skipDirNames) {
            if (string.IsNullOrEmpty(rootDir) || rootDir.Trim().Length == 0) {
                yield break;
            }

            // .NET 3.5 uyumlu - Tuple yerine basit queue
            Queue<string> pathQueue = new Queue<string>();
            Queue<int> depthQueue = new Queue<int>();
            pathQueue.Enqueue(rootDir);
            depthQueue.Enqueue(0);

            while (pathQueue.Count > 0) {
                string currentPath = pathQueue.Dequeue();
                int currentDepth = depthQueue.Dequeue();
                if (currentDepth >= maxDepth) {
                    continue;
                }

                string[] subDirs;
                try {
                    subDirs = Directory.GetDirectories(currentPath);
                }
                catch {
                    continue;
                }

                foreach (string subDir in subDirs) {
                    string name = Path.GetFileName(subDir);
                    if (!string.IsNullOrEmpty(name) && skipDirNames != null && skipDirNames.Contains(name)) {
                        continue;
                    }

                    DirectoryInfo info;
                    try {
                        info = new DirectoryInfo(subDir);
                    }
                    catch {
                        continue;
                    }

                    if ((info.Attributes & FileAttributes.ReparsePoint) != 0) {
                        continue;
                    }

                    yield return subDir;
                    pathQueue.Enqueue(subDir);
                    depthQueue.Enqueue(currentDepth + 1);
                }
            }
        }

        private bool LooksLikeVitisDir(string dir) {
            DirectoryInfo info;
            try {
                info = new DirectoryInfo(dir);
            }
            catch {
                return false;
            }

            string name = info.Name.ToLowerInvariant();
            if (name.Contains("vitis") || name.Contains("sdk")) {
                return true;
            }

            string metadataDir = Path.Combine(dir, ".metadata");
            if (!Directory.Exists(metadataDir)) {
                return false;
            }

            try {
                foreach (string subDir in Directory.GetDirectories(dir)) {
                    if (Directory.GetFiles(subDir, "*.spr", SearchOption.TopDirectoryOnly).Length > 0) {
                        return true;
                    }
                }
            }
            catch {
                return false;
            }

            return false;
        }

        private string EnsureUniqueName(string baseName, HashSet<string> usedNames) {
            string cleanBase = string.IsNullOrEmpty(baseName) ? "vitis" : baseName;
            string candidate = cleanBase;
            int counter = 2;

            while (!usedNames.Add(candidate)) {
                candidate = cleanBase + "_" + counter;
                counter++;
            }

            return candidate;
        }

        private IEnumerable<string> BuildHardwareExportSearchRoots(IEnumerable<VitisProjectInfo> vitisProjects) {
            HashSet<string> roots = new HashSet<string>(StringComparer.OrdinalIgnoreCase);

            // Sadece proje klasörünü ekle
            AddSearchRoot(roots, projectFileDir);
            
            // Vitis klasörlerini ekle
            foreach (VitisProjectInfo project in vitisProjects) {
                AddSearchRoot(roots, project.SourceDir);
            }

            // NOT: Parent klasöre BAKMA - başka projelerin XSA'larını da alır!
            // Sadece proje klasörü ve Vitis klasörleri yeterli

            return roots;
        }

        private void AddSearchRoot(HashSet<string> roots, string path) {
            if (string.IsNullOrEmpty(path) || path.Trim().Length == 0) {
                return;
            }

            try {
                string normalized = NormalizePath(path);
                if (Directory.Exists(normalized)) {
                    roots.Add(normalized);
                }
            }
            catch {
            }
        }

        private bool IsSameFile(string left, string right) {
            try {
                FileInfo leftInfo = new FileInfo(left);
                FileInfo rightInfo = new FileInfo(right);
                return leftInfo.Length == rightInfo.Length &&
                    leftInfo.LastWriteTimeUtc == rightInfo.LastWriteTimeUtc;
            }
            catch {
                return false;
            }
        }

        private string GetUniqueTargetFilePath(string targetDir, string fileName, HashSet<string> usedTargets) {
            string baseName = Path.GetFileNameWithoutExtension(fileName);
            string ext = Path.GetExtension(fileName);
            string candidate = Path.Combine(targetDir, fileName);
            string normalizedCandidate = NormalizePath(candidate);
            int counter = 2;

            while (usedTargets.Contains(normalizedCandidate) || File.Exists(candidate)) {
                string altName = baseName + "_" + counter + ext;
                candidate = Path.Combine(targetDir, altName);
                normalizedCandidate = NormalizePath(candidate);
                counter++;
            }

            usedTargets.Add(normalizedCandidate);
            return candidate;
        }

        private string GetUniqueTargetDirectoryPath(string targetRoot, string dirName, HashSet<string> usedTargets) {
            string candidate = Path.Combine(targetRoot, dirName);
            string normalizedCandidate = NormalizePath(candidate);
            int counter = 2;

            while (usedTargets.Contains(normalizedCandidate) || Directory.Exists(candidate)) {
                string altName = dirName + "_" + counter;
                candidate = Path.Combine(targetRoot, altName);
                normalizedCandidate = NormalizePath(candidate);
                counter++;
            }

            usedTargets.Add(normalizedCandidate);
            return candidate;
        }

        // Vitis project klasörünü kopyala (varsa)
        private void CopyVitisProject() {
            try {
                // Vitis klasörünü ara - farklı konumlarda olabilir
                List<VitisProjectInfo> vitisProjects = FindVitisProjects();

                foreach (VitisProjectInfo vitisProject in vitisProjects) {
                    string targetVitisDir = Path.Combine(
                        FolderStructure.AbsoluteDir(SourceType.VITIS),
                        vitisProject.TargetName);

                    Log("Found Vitis project: " + vitisProject.SourceDir);
                    DirectoryCopyVitis(vitisProject.SourceDir, targetVitisDir);
                    Log("Copied Vitis project to: " + targetVitisDir);
                }

                // ELF ve XSA dosyalarını kopyala - Vitis olmasa bile XSA olabilir
                if (vitisProjects.Count > 0) {
                    CopyVitisElfOutputs(vitisProjects);
                }
                CopyHardwareExports(BuildHardwareExportSearchRoots(vitisProjects));
            }
            catch (Exception ex) {
                Log("Warning - Error while copying Vitis project: " + ex.Message);
            }
        }

        // Copy ELF outputs from Vitis build results into elf/
        private void CopyVitisElfOutputs(IEnumerable<VitisProjectInfo> vitisProjects) {
            try {
                HashSet<string> copiedNames = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
                string elfDir = FolderStructure.AbsoluteDir(SourceType.ELF);

                foreach (VitisProjectInfo vitisProject in vitisProjects) {
                    string vitisDir = vitisProject.SourceDir;
                    if (!Directory.Exists(vitisDir)) {
                        continue;
                    }

                    List<string> buildDirs = new List<string>();
                    buildDirs.AddRange(Directory.GetDirectories(vitisDir, "Debug", SearchOption.AllDirectories));
                    buildDirs.AddRange(Directory.GetDirectories(vitisDir, "Release", SearchOption.AllDirectories));

                    foreach (string buildDir in buildDirs) {
                        string[] elfFiles;
                        try {
                            elfFiles = Directory.GetFiles(buildDir, "*.elf", SearchOption.TopDirectoryOnly);
                        }
                        catch (Exception ex) {
                            Log("Warning - Could not scan elf files: " + buildDir + " - " + ex.Message);
                            continue;
                        }

                        foreach (string elfFile in elfFiles) {
                            string fileName = Path.GetFileName(elfFile);
                            
                            // Aynı isimli ELF varsa numaralandır
                            string targetName = fileName;
                            string baseName = Path.GetFileNameWithoutExtension(fileName);
                            int counter = 2;
                            while (copiedNames.Contains(targetName)) {
                                targetName = baseName + "_" + counter + ".elf";
                                counter++;
                            }
                            copiedNames.Add(targetName);

                            string targetPath = Path.Combine(elfDir, targetName);

                            try {
                                File.Copy(elfFile, targetPath, true);
                                Log("Copied elf file: " + elfFile + " -> " + targetName);
                            }
                            catch (Exception ex) {
                                Log("Warning - Could not copy elf file: " + elfFile + " - " + ex.Message);
                            }
                        }
                    }
                }
            }
            catch (Exception ex) {
                Log("Warning - Error while copying elf outputs: " + ex.Message);
            }
        }

        // Copy Vitis project files with source-only filtering.
        private void DirectoryCopyVitis(string sourceDir, string destDir) {
            DirectoryInfo dir = new DirectoryInfo(sourceDir);
            
            // Atlanacak klasör desenleri
            string[] excludeDirs = new string[] {
                "Debug", "Release", ".metadata", "RemoteSystemsTempFiles",
                "_ide", "Hardware", ".Xil"
            };
            
            // Atlanacak dosya desenleri - xsa zaten hw_export'ta
            string excludeFilePattern = @"\.(o|d|elf|map|log|jou|xsa)$";
            
            if (!dir.Exists) {
                return;
            }

            Directory.CreateDirectory(destDir);
            DirectoryInfo[] dirsIn = dir.GetDirectories();
            FileInfo[] filesIn = dir.GetFiles();

            foreach (FileInfo file in filesIn) {
                if (!Regex.IsMatch(file.Name, excludeFilePattern, RegexOptions.IgnoreCase)) {
                    string tempPath = Path.Combine(destDir, file.Name);
                    try {
                        file.CopyTo(tempPath);
                    }
                    catch (Exception ex) {
                        Log("Warning - Could not copy Vitis file: " + file.FullName + " - " + ex.Message);
                    }
                }
            }

            foreach (DirectoryInfo dirIn in dirsIn) {
                // Hariç tutulan klasörleri atla
                if (!excludeDirs.Contains(dirIn.Name, StringComparer.OrdinalIgnoreCase)) {
                    string tempPath = Path.Combine(destDir, dirIn.Name);
                    DirectoryCopyVitis(dirIn.FullName, tempPath);
                }
            }
        }

        // Hardware Export (.xsa) dosyalarını kopyala
        private void CopyHardwareExports(IEnumerable<string> searchRoots) {
            try {
                // Proje klasöründe ve alt klasörlerinde XSA dosyalarını ara
                if (searchRoots == null) {
                    return;
                }

                HashSet<string> roots = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
                foreach (string root in searchRoots) {
                    AddSearchRoot(roots, root);
                }

                if (roots.Count == 0) {
                    return;
                }

                string targetDir = FolderStructure.AbsoluteDir(SourceType.HW_EXPORT);
                Directory.CreateDirectory(targetDir);

                HashSet<string> copiedSources = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
                HashSet<string> usedTargets = new HashSet<string>(StringComparer.OrdinalIgnoreCase);

                foreach (string existingFile in Directory.GetFiles(targetDir, "*.xsa", SearchOption.TopDirectoryOnly)) {
                    usedTargets.Add(NormalizePath(existingFile));
                }

                foreach (string root in roots) {
                    string[] xsaFiles;
                    try {
                        xsaFiles = Directory.GetFiles(root, "*.xsa", SearchOption.AllDirectories);
                    }
                    catch (Exception ex) {
                        Log("Warning - Could not scan XSA files: " + root + " - " + ex.Message);
                        continue;
                    }

                    foreach (string xsaFile in xsaFiles) {
                        string normalizedSource = NormalizePath(xsaFile);
                        if (copiedSources.Contains(normalizedSource)) {
                            continue;
                        }

                        string fileName = Path.GetFileName(xsaFile);
                        string targetXsa = Path.Combine(targetDir, fileName);

                        if (File.Exists(targetXsa)) {
                            if (IsSameFile(targetXsa, xsaFile)) {
                                usedTargets.Add(NormalizePath(targetXsa));
                                copiedSources.Add(normalizedSource);
                                continue;
                            }

                            targetXsa = GetUniqueTargetFilePath(targetDir, fileName, usedTargets);
                        }
                        else {
                            usedTargets.Add(NormalizePath(targetXsa));
                        }

                        try {
                            File.Copy(xsaFile, targetXsa);
                            copiedSources.Add(normalizedSource);
                            Log("Copied XSA file: " + xsaFile);
                        }
                        catch (Exception ex) {
                            Log("Warning - Could not copy XSA file: " + xsaFile + " - " + ex.Message);
                        }
                    }
                }

                if (copiedSources.Count == 0) {
                    Log("No XSA files found in search roots.");
                }
            }
            catch (Exception ex) {
                Log("Warning - Error while copying hardware exports: " + ex.Message);
            }
        }

        /// <summary>
        /// Recursive olarak component.xml içeren tüm IP klasörlerini bul ve kopyala
        /// Herhangi bir derinlikte olabilir: repo/ip, repo/sub/ip, repo/a/b/c/ip
        /// </summary>
        private void FindAndCopyCustomIps(string searchDir, string targetDir) {
            FindAndCopyCustomIps(
                searchDir,
                targetDir,
                new HashSet<string>(StringComparer.OrdinalIgnoreCase),
                new HashSet<string>(StringComparer.OrdinalIgnoreCase));
        }

        private void FindAndCopyCustomIps(string searchDir, string targetDir, HashSet<string> copiedIpDirs, HashSet<string> usedTargetDirs) {
            try {
                DirectoryInfo dir = new DirectoryInfo(searchDir);
                if (!dir.Exists) return;

                string componentPath = Path.Combine(searchDir, "component.xml");

                // Bu klasörde component.xml var mı?
                if (File.Exists(componentPath)) {
                    string normalizedSource = NormalizePath(searchDir);
                    if (copiedIpDirs.Contains(normalizedSource)) {
                        return;
                    }
                    // Bu bir IP - kopyala
                    string ipName = dir.Name;
                    string targetPath = GetUniqueTargetDirectoryPath(targetDir, ipName, usedTargetDirs);
                    CopyIpRepoMinimal(searchDir, targetPath);
                    copiedIpDirs.Add(normalizedSource);
                    Log("Copied custom IP: " + ipName);
                    return; // Alt klasörlere bakma - bu IP'nin içi
                }

                // Alt klasörlerde recursive ara
                foreach (DirectoryInfo subDir in dir.GetDirectories()) {
                    // Skip common non-IP directories
                    string name = subDir.Name;
                    if (name.StartsWith(".", StringComparison.Ordinal) ||
                        name.Equals("sim", StringComparison.OrdinalIgnoreCase) ||
                        name.Equals("synth", StringComparison.OrdinalIgnoreCase) ||
                        name.Equals("project", StringComparison.OrdinalIgnoreCase) ||
                        name.Equals("managed_ip_project", StringComparison.OrdinalIgnoreCase) ||
                        name.Equals(".Xil", StringComparison.OrdinalIgnoreCase) ||
                        name.Equals("ip_user_files", StringComparison.OrdinalIgnoreCase) ||
                        name.Equals(".git", StringComparison.OrdinalIgnoreCase) ||
                        name.Equals(".svn", StringComparison.OrdinalIgnoreCase)) {
                        continue;
                    }
                    FindAndCopyCustomIps(subDir.FullName, targetDir, copiedIpDirs, usedTargetDirs);
                }
            }
            catch (Exception ex) {
                Log("Warning - Error searching for custom IPs in " + searchDir + ": " + ex.Message);
            }
        }

        /// <summary>
        /// Custom IP Repository için minimal kopyalama
        /// Sadece projeyi yeniden oluşturmak için gerekli dosyalar
        /// </summary>
        private void CopyIpRepoMinimal(string sourceDir, string destDir) {
            DirectoryInfo dir = new DirectoryInfo(sourceDir);
            
            if (!dir.Exists) {
                return;
            }

            // Sadece gerekli uzantılar
            string[] includeExtensions = new string[] {
                ".v", ".sv", ".vhd", ".vhdl",    // HDL kaynak
                ".xml",                           // component.xml - zorunlu
                ".tcl",                           // xgui, packaging script
                ".xdc",                           // constraints
                ".xci",                           // IP definition
            };
            
            // Hariç tutulacak klasörler - oluşturulan/build çıktıları
            string[] excludeDirs = new string[] {
                "sim", "synth", "project", "managed_ip_project",
                ".Xil", "ip_user_files", ".git", ".svn"
            };

            Directory.CreateDirectory(destDir);

            foreach (FileInfo file in dir.GetFiles()) {
                bool include = false;
                foreach (string ext in includeExtensions) {
                    if (file.Name.EndsWith(ext, StringComparison.OrdinalIgnoreCase)) {
                        include = true;
                        break;
                    }
                }
                
                if (include) {
                    try {
                        file.CopyTo(Path.Combine(destDir, file.Name));
                    }
                    catch { }
                }
            }

            foreach (DirectoryInfo subDir in dir.GetDirectories()) {
                if (!excludeDirs.Contains(subDir.Name, StringComparer.OrdinalIgnoreCase)) {
                    CopyIpRepoMinimal(subDir.FullName, Path.Combine(destDir, subDir.Name));
                }
            }
        }
    }
}
